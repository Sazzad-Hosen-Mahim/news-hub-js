<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-gH2yIJqKdNHPEq0n4Mqa/HGKIhSkIHeL5AyhkYV8i59U5AR6csBvApHHNl/vI1Bx" crossorigin="anonymous">
    <link rel="stylesheet" href="style/styles.css">
    <title>Blog</title>
</head>

<body class="bg-light">

    <header class="container">

        <nav class="navbar navbar-expand-lg bg-light p-3">
            <div class="container-fluid">
                <a class="navbar-brand text-primary" href="#">News Hub</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse"
                    data-bs-target="#navbarNavAltMarkup" aria-controls="navbarNavAltMarkup" aria-expanded="false"
                    aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse" id="navbarNavAltMarkup">
                    <div class="navbar-nav">
                        <a class="nav-link active" aria-current="page" href="index.html">Home</a>
                        <a class="nav-link" href="blog.html">Blog</a>

                    </div>
                </div>
            </div>
        </nav>
    </header>


    <main>

        <div class="bg-white question container mt-5 p-5">
            <h2>1. What is the difference between Var, Let and Const?</h2>
            <p class="mt-5 fw-semibold fs-5 p-5">Before the advent of ES6, var declarations ruled. var declarations are
                globally scoped or function/locally scoped.
                The scope is global when a var variable is declared outside a function. This means that any variable
                that is declared with var outside a function block is available for use in the whole window. Var
                variables can be re-declared and updated. var variables are hoisted to the top of their scope and
                initialized with a value of undefined.</p>
        </div>
        <div class="bg-white question container mt-5">
            <h2>2. What is the difference between regular function and arrow function?</h2>
            <p class="mt-5 fw-semibold fs-5"> [i]. syntax = var add = function(x, y) {
                return x + y;
                };
                // ES6
                let add = (x, y) => { return x + y };
                <br>
                [ii]. Arrow functions do not have an arguments binding. However, they have access to the arguments object
                of the closest non-arrow parent function. Named and rest parameters are heavily relied upon to capture
                the arguments passed to arrow functions.
                <br>
                [iii]. Unlike regular functions, arrow functions do not have their own this. The value of this inside an
                arrow function remains the same throughout the lifecycle of the function and is always bound to the
                value of this in the closest non-arrow parent function.
                <br>
                [iv]. Regular functions created using function declarations or expressions are constructible and callable.
                Since regular functions are constructible, they can be called using the new keyword.

                However, the arrow functions are only callable and not constructible, i.e arrow functions can never be
                used as constructor functions. Hence, they can never be invoked with the new keyword.</p>
        </div>
        <div class="bg-white question container mt-5">
            <h2>3. Why you use template string?</h2>
            <p class="mt-5 fw-semibold fs-5"> Template literals are enclosed by backtick (`) characters instead of double or single quotes.
                <br>
                [i]. Multi-line strings: 
                Any newline characters inserted in the source are part of the template literal.
                <br>
                [ii]. String interpolation: With template literals, you can avoid the concatenation operator — and improve the readability of your code — by using placeholders of the form ${expression} to perform substitutions for embedded expressions.
                <br>
                [iii]. Nesting templates: In certain cases, nesting a template is the easiest (and perhaps more readable) way to have configurable strings. Within a backtick-delimited template, it is simple to allow inner backticks by using them inside an ${expression} placeholder within the template.

            </p>
        </div>

    </main>


    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.0/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-A3rJD856KowSb7dwlZdYEkO39Gagi7vIsF0jrRAoQmDKKtQBHUuLZ9AsSv4jD4Xa" crossorigin="anonymous">
    </script>
</body>

</html>